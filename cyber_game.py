from chrono import *
from nodes import *
from users import *
import numpy as np
from collections import deque, Counter
import os, sys, random, json, re

# Add conditional agency for the attacker
# for instance, simulate stealth, ransomware, etc.
# Write up a description of what we're doing, with a few questions
# Make this an attacker-defender game
# Create a generator model

num_admins = 4

class game_space:
    def __init__(self, num_nodes):
        self.compromised_modifier = 5e-4
        self.working_modifier = 1e-5
        self.anomaly_types = ["login", "launch", "netin", "netout", "apc", "activ", "file"]
        # If the reading taken is above this value, an anomaly is generated
        self.anomaly_thresholds =  {"login": 0.20,
                                    "launch": 0.25,
                                    "netin": 0.25,
                                    "netout": 0.30,
                                    "apc": 0.20,
                                    "activ": 0.25,
                                    "file": 0.35}
        # Chance of a type of event compromising a node
        # In some cases, the event must have been generated by a compromised node
        self.compromise_chances =  {"login": 0.40,
                                    "launch": 0.90,
                                    "netin": 0.90,
                                    "netout": 0.80,
                                    "apc": 0.20,
                                    "activ": 0.80,
                                    "file": 0.90}
        # The likelyhood that a slightly increased anomaly value is created by an event
        self.anomaly_chances =  {"login": 5e-4,
                                 "launch": 1e-6,
                                 "netin": 2e-6,
                                 "netout": 1e-7,
                                 "apc": 1e-6,
                                 "activ": 8e-6,
                                 "file": 1e-8}
        self.num_nodes = num_nodes
        self.num_servers = max(4, int(num_nodes)*0.01)
        self.num_workstations = self.num_nodes - self.num_servers
        self.chrono = Chrono()
        # Create the required number of nodes 
        # Assigning some of them as servers, the rest as workstations
        # Record which nodes are which
        self.nodes = []
        self.all_nodes = []
        self.workstations = []
        self.servers  = []
        for index in range(self.num_nodes):
            self.all_nodes.append(index)
            if index < self.num_workstations:
                self.nodes.append(Node(index, "workstation"))
                self.workstations.append(index)
            else:
                self.nodes.append(Node(index, "server"))
                self.servers.append(index)
        # Create users and assign them to workstation nodes
        # Userids should map to nodeids
        self.num_admins = num_admins
        self.num_users = len(self.workstations) - self.num_admins
        self.admin_ids = random.sample(self.workstations, self.num_admins)
        self.user_ids = []
        self.users = []
        self.admins = []
        for index in self.workstations:
            if index in self.admin_ids:
                self.nodes[index].node_type = "admin"
                u = User(index, "admin", "admin")
                self.admins.append(u)
            else:
                u = User(index, "user", self.nodes[index].node_subtype)
                self.user_ids.append(index)
            self.users.append(u)
        self.all_ids = set(self.admin_ids).union(set(self.user_ids))
        # Get lists of all node types
        self.node_map = self.get_node_map(self.nodes)
        # Create a list of "favourites" for each user
        # This is a list of nodes they'll most likely communicate with
        self.general_servers = self.node_map["server"]["general"]
        for user in self.users:
            favourites = []
            index = user.index
            utype = user.user_type
            ustype = user.user_subtype
            if utype == "admin":
                favourites = self.servers
            else:
                specific_servers = self.node_map["server"][ustype]
                favourites = set(self.general_servers).union(set(specific_servers))
                random_fav = random.sample(self.node_map["workstation"][ustype],
                                           min(3, len(self.node_map["workstation"][ustype])))
                favourites = favourites.union(set(random_fav))
            user.set_favourites(favourites)
        # Set user's awake/asleep status (whether they're currently working)
        for user in self.users:
            user.set_work_time(self.chrono)
            user.working = user.is_working(self.chrono)

        # Set node sleep status
        self.set_node_sleep_status()

        # Gather initial readings
        self.max_readings = 100
        self.total_anomalies = 0
        self.last_anomalies = deque()
        self.all_interactions = {}
        self.attacker_interactions = []
        self.reported = []
        self.all_events = []
        self.reported = self.get_readings()


    ###################
    # Step function
    ###################
    def step(self):
        changed_day = self.chrono.increment_chrono()
        if changed_day == True:
            for user in self.users:
                user.set_work_time(self.chrono)
                user.working = user.is_working(self.chrono)
        self.set_node_sleep_status()
        self.reported = self.get_readings()

    # Helper functions
    def get_node_map(self, nodes):
        node_map = {}
        for node in nodes:
            ntype = node.node_type
            if ntype not in node_map:
                node_map[ntype] = {}
            nstype = node.node_subtype
            if nstype not in node_map[ntype]:
                node_map[ntype][nstype] = []
            node_map[ntype][nstype].append(node.index)
        return node_map

    def set_node_sleep_status(self):
        for user in self.users:
            index = user.index
            is_working = user.is_working(self.chrono)
            sleeps_nights = user.sleeps_nights
            sleeps_weekends = user.sleeps_weekends
            is_weekend = self.chrono.is_weekend()
            is_asleep = False
            if random.random() > 0.99:
                is_asleep = True
            if sleeps_weekends == True and is_weekend == True:
                is_asleep = True
            if sleeps_nights == True and is_working == False:
                is_asleep = True
            self.nodes[index].is_asleep = is_asleep

    def get_compromised_nodes(self):
        compromised = []
        for node in self.nodes:
            if node.compromised == True:
                compromised.append(node.index)
        return compromised

    def get_compromised_users(self):
        compromised = []
        for user in self.users:
            if user.compromised == True:
                compromised.append(user.index)
        return compromised

    #########################
    # Print stuff
    #########################
    def get_printable(self, infected, reported, asleep, server):
        if reported == True:
            return "\x1b[0;36;46m" + "■" + "\x1b[0m"
        if asleep == True:
            return "\x1b[0;30;100m" + "■" + "\x1b[0m"
        if server == True:
            if infected == True:
                return "\x1b[0;35;41m" + "■" + "\x1b[0m"
            else:
                return "\x1b[0;37;45m" + "■" + "\x1b[0m"
        else:
            if infected == True:
                return "\x1b[0;30;41m" + "■" + "\x1b[0m"
            else:
                return "\x1b[0;30;47m" + "■" + "\x1b[0m"

    def print_whole_network(self):
        state = np.zeros(self.num_nodes)
        for index in self.get_compromised_nodes():
            state[index] = 1
        state = np.reshape(state, (-1, 100))
        lines = state.shape[0]
        la = list(self.last_anomalies)[-lines:]
        printable = ""
        for index, column in enumerate(state):
            printable += " "
            for i2, item in enumerate(column):
                node = index * (len(column)) + i2
                reported = False
                if node in self.reported:
                    reported = True
                asleep = self.nodes[node].is_asleep
                server = self.nodes[node].is_server
                printable += self.get_printable(item, reported, asleep, server)
            if len(la) > index:
                printable += " " + la[index]
            printable += "\n"
        return printable

    def print_user_status(self, index):
        user = self.users[index]
        if user.is_admin == True:
            if user.compromised == True:
                return '\x1b[1;31;46m' + "%04d"%index + '\x1b[0m'
            else:
                return '\x1b[1;36;40m' + "%04d"%index + '\x1b[0m'
        else:
            if user.compromised == True:
                return '\x1b[1;31;43m' + "%04d"%index + '\x1b[0m'
            else:
                return '\x1b[1;33;40m' + "%04d"%index + '\x1b[0m'

    def print_node_status(self, index):
        node = self.nodes[index]
        if node.is_server == True:
            if node.compromised == True:
                return '\x1b[1;31;45m' + "%04d"%index + '\x1b[0m'
            else:
                return '\x1b[1;35;40m' + "%04d"%index + '\x1b[0m'
        else:
            if node.compromised == True:
                return '\x1b[1;31;42m' + "%04d"%index + '\x1b[0m'
            else:
                return '\x1b[1;32;40m' + "%04d"%index + '\x1b[0m'

    def print_interactions(self, index):
        msg = "[ "
        for source, targets in self.nodes[index].interactions.items():
            for target, count in targets.most_common():
                msg += "[" + self.print_node_status(source) + ":" 
                msg += self.print_node_status(target) + "(" + str(count) + ")] "
        msg += " ]"
        return msg

    def print_attacker_interactions(self):
        msg = "["
        for item in self.attacker_interactions:
            msg += "[" + item + "]"
        msg += "]"
        return msg

    def print_chrono(self):
        return self.chrono.print_chrono()

    #########################
    # Anomaly detection stuff
    #########################

    # Outgoing network connection
    # Should be rare for machines to directly connect to others within a company network
    # with the exception of traffic from specific servers
    # However, in some companies, this does happen
    def process_netout(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = node.index
        target = None
        anomaly_chance = self.anomaly_chances[rtype]
        if user.working == False:
            anomaly_chance += self.working_modifier
        if user.compromised == True:
            anomaly_chance += self.compromised_modifier
        if node.compromised == True:
            anomaly_chance += self.compromised_modifier
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            target_node = random.choice(self.nodes)
            target = target_node.index
            if target != source and target not in user.favourites and target_node.is_asleep == False:
                metadata = "Outgoing connection from node: " + self.print_node_status(source)
                metadata += " to node: " + self.print_node_status(target)
                if user.compromised or node.compromised:
                    self.compromise_node(target_node, rtype)
        return source, target, reading, metadata

    # Incoming network connection
    # Should be rare for machines to directly connect to others within a company network
    # with the exception of traffic from specific servers
    # However, in some companies, this does happen
    def process_netin(self, node, user, rtype):
        metadata = None
        reading = 0.0
        target = node.index
        source = None
        anomaly_chance = self.anomaly_chances[rtype]
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            source_node = random.choice(self.nodes)
            source = source_node.index
            if source != target and source_node.is_asleep == False:
                metadata = "Incoming connection from node: " + self.print_node_status(source)
                metadata += " to node: " + self.print_node_status(target)
                if source_node.compromised == True:
                    self.compromise_node(node, rtype)
        return source, target, reading, metadata

    # Unexpected file access
    # Can be indicative of recon or exfiltration
    def process_file(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = user.index
        target = None
        anomaly_chance = self.anomaly_chances[rtype]
        if user.working == False:
            anomaly_chance += self.working_modifier
        if user.compromised == True:
            anomaly_chance += self.compromised_modifier
        if node.compromised == True:
            anomaly_chance += self.compromised_modifier
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            target_node = random.choice(self.nodes)
            target = target_node.index
            if target != source and target not in user.favourites and target_node.is_asleep == False:
                metadata = "User: " + self.print_user_status(source)
                metadata += " accessed file on node: " + self.print_node_status(target)
                if user.compromised or node.compromised:
                    self.compromise_node(target_node, rtype)
        return source, target, reading, metadata

    # Unexpected process launch
    # This occurs when a user launches a process they haven't launched before
    # It can be indicative of a change of role, uptake of new software, or compromise
    def process_launch(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = node.index
        target = node.index
        anomaly_chance = self.anomaly_chances[rtype]
        if user.working == False:
            anomaly_chance += self.working_modifier
        if user.compromised == True:
            anomaly_chance += self.compromised_modifier
        if node.compromised == True:
            anomaly_chance += self.compromised_modifier
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            metadata = "Unexpected process launch on node: " + self.print_node_status(target)
            self.compromise_node(node, rtype)
            if node.compromised == True:
                user.compromised = True
        return source, target, reading, metadata

    # Anomalous process creation
    # This is typically indicative of someone getting phished, leading to compromise
    # It is a rare event and doesn't depend on previous compromise status
    # Probably shouldn't happen on servers
    def process_apc(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = node.index
        target = node.index
        anomaly_chance = self.anomaly_chances[rtype]
        if node.is_server == True:
            anomaly_chance = 0
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            metadata = "Anomalous process creation pair on node: " + self.print_node_status(target)
            self.compromise_node(node, rtype)
            if node.compromised == True:
                user.compromised = True
        return source, target, reading, metadata

    # Generate a login anomaly - when an unexpected user logs into a node
    # For workstations, only the owner and admin usually log in
    # For servers, only admins usually log in
    def process_login(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = None
        target = node.index
        anomaly_chance = self.anomaly_chances[rtype]
        compromised = node.compromised
        if user.compromised == True:
            anomaly_chance += self.compromised_modifier
        if node.compromised == True:
            anomaly_chance += self.compromised_modifier
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            login_user = random.choice(self.users)
            source = login_user.index
            report = False
            if login_user.is_admin == True:
                if target not in login_user.favourites:
                    report = True
            if login_user.compromised == True:
                report = True
                self.compromise_node(node, rtype)
                if node.compromised == True:
                    user.compromised = True
            if report == True:
                login_user.add_favourite(node.index)
                metadata = "User: " + self.print_user_status(source)
                metadata += " unexpected login on node: " + self.print_node_status(target)
        return source, target, reading, metadata

    # Generate an activity anomaly, i.e. activity at an unusual time
    def process_activ(self, node, user, rtype):
        metadata = None
        reading = 0.0
        source = node.index
        target = user.index
        anomaly_chance = self.anomaly_chances[rtype]
        if user.working == False:
            anomaly_chance += self.working_modifier
        if user.compromised == True:
            anomaly_chance += self.compromised_modifier
        if node.compromised == True:
            anomaly_chance += self.compromised_modifier
        reading = self.generate_reading(anomaly_chance)
        if reading > self.anomaly_thresholds[rtype]:
            metadata = "User: " + self.print_user_status(target)
            metadata += " unexpected activity on node: " + self.print_node_status(source)
        return source, target, reading, metadata

    # This code is called when a compromised node interacts with another node
    # It determines whether to compromise the other node
    def compromise_node(self, node, rtype):
        if node.compromised == True:
            return
        compromise_chance = self.compromise_chances[rtype]
        if node.is_server == True:
            compromise_chance -= 0.5
        if np.random.random() > compromise_chance:
            node.compromised = True

    def compromise_user(self, user, rtype):
        if user.compromised == True:
            return
        compromise_chance = self.compromise_chances[rtype]
        if np.random.random() > compromise_chance:
            user.compromised = True

    # Helper functions
    def generate_reading(self, anomaly_chance):
        mu, sigma = 0.1, 0.01
        val = np.random.normal(mu, sigma)
        if np.random.random() < anomaly_chance:
            val += np.random.normal(0.3, 0.1)
        return val

    def get_function(self, func_name):
        def func_not_found():
            print("Function " + func_name + " not found")
        func = getattr(self, func_name, func_not_found)
        return func

    def get_readings(self):
        reported = []
        for node in self.nodes:
            if node.is_asleep == True:
                continue
            index = node.index
            if node.is_server:
                user = random.choice(self.admins)
            else:
                user = self.users[index]
            for rtype in self.anomaly_types:
                function = self.get_function("process_" + rtype)
                source, target, reading, metadata = function(node, user, rtype)
                if metadata is not None:
                    event = {}
                    event["source"] = source
                    event["target"] = target
                    event["user"] = user.index
                    event["user_compromised"] = user.compromised
                    event["node_compromised"] = node.compromised
                    event["node_is_server"] = node.is_server
                    event["reading"] = reading
                    event["type"] = rtype
                    event["time"] = self.chrono.print_chrono()
                    event["metadata"] = metadata
                    self.all_events.append(event)
                    self.total_anomalies += 1
                    self.nodes[index].anomaly_counter[rtype] += 1
                    msg = ""
                    msg += "Node: " + self.print_node_status(index)
                    #msg += "  " + self.chrono.print_chrono()
                    msg += "  Type: " + rtype
                    msg += " "*(8-len(rtype)) + metadata
                    self.last_anomalies.append(msg)
                    if len(self.last_anomalies) > self.max_readings:
                        self.last_anomalies.popleft()
                    self.add_interaction(node, source, target)
                    self.build_all_interactions(source, target)
                    self.build_attacker_interactions(source, target, rtype)
                    reported.append(index)
        return reported

    def save_events(self, filename):
        with open(filename, "w") as f:
            f.write(json.dumps(self.all_events, indent=4))

    #########################
    # Interactions stuff
    #########################
    def add_interaction(self, node, source, target):
        if source not in node.interactions:
            node.interactions[source] = Counter()
        node.interactions[source][target] += 1
        if source != node.index:
            self.combine_interactions(node, source)
        if target != node.index:
            self.combine_interactions(node, target)

    def combine_interactions(self, node, index):
        inter1 = self.nodes[index].interactions
        inter2 = node.interactions
        combined = {**inter1, **inter2}
        self.nodes[index].interactions = dict(combined)
        node.interactions = dict(combined)

    def build_all_interactions(self, source, target):
        if source == target:
            return
        if source not in self.all_interactions:
            self.all_interactions[source] = Counter()
        self.all_interactions[source][target] += 1

    def save_interactions(self, filename):
        with open(filename, "w") as f:
            f.write("Source,Target,Weight\n")
            for source, targets in self.all_interactions.items():
                for target, weight in targets.items():
                    f.write(str(source)+","+str(target)+","+str(weight)+"\n")

    def build_attacker_interactions(self, source, target, rtype):
        source_compromised = False
        target_compromised = False
        source_string = None
        target_string = None
        source_type = "node"
        target_type = "node"
        # Target is user: activ
        if rtype in ["activ"]:
            target_type = "user"
            if self.users[target].compromised == True:
                target_compromised = True
        # Source is user: login
        if rtype in ["login", "file"]:
            source_type = "user"
            if self.users[source].compromised == True:
                source_compromised = True
        # Target is host: login, apc, launch, file, netin, netout
        if rtype in ["login", "apc", "launch", "file", "netin", "netout"]:
            target_type = "node"
            if self.nodes[target].compromised == True:
                target_compromised = True
        # Source is host: activ, apc, launch, file, netin, netout
        if rtype in ["login", "apc", "launch", "netin", "netout"]:
            source_type = "node"
            if self.nodes[source].compromised == True:
                source_compromised = True
        if source_compromised == True or target_compromised == True:
            if source_type == "node":
                source_string = self.print_node_status(self.nodes[source].index)
            else:
                source_string = self.print_user_status(self.users[source].index)
            if target_type == "node":
                target_string = self.print_node_status(self.nodes[target].index)
            else:
                target_string = self.print_user_status(self.users[target].index)
            self.attacker_interactions.append(source_string + ":" + target_string)

    def get_top_interactions(self):
        num_inter = Counter()
        for node in self.nodes:
            c = 0
            for source, targets in node.interactions.items():
                for target, count in targets.most_common():
                    c += count
            num_inter[node.index] = c
        return num_inter
